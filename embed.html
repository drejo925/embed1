<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Nunito+Sans:wght@500&display=swap" rel="stylesheet">
    <title>Doughnut Viewer</title>
</head>
<style>
    body {
        font-family: 'Nunito Sans', sans-serif;
        font-weight: 500;
        font-size: 19px;
        line-height: 1.5;
        color: rgb(34, 35, 34);
        margin: 5px;
        background-color: #fff; /* White background */
    }

    * {
        box-sizing: border-box;
    }

    /* Header-like elements */
    #globalPlotTitle,
    #controlsBox > label, /* Targets direct label children of controlsBox */
    #dataTableContainer h4 {
        font-family: 'Montserrat', sans-serif;
        font-weight: 700;
        font-size: 27px;
        line-height: 1.4;
        color: rgb(34, 35, 34);
    }

    /* --- Containers --- */
    /* Wrapper for Canvas + Controls */
    #globalDisplayWrapper {
        /* max-width: 800px; */
        max-width: 1040px; /* Adjusted for 1080px site width */
        margin: 15px auto;
        display: flex; /* Enable Flexbox */
        align-items: flex-start; /* Align items top */
        gap: 15px; /* Space between control column and canvas */
    }

    /* *** UPDATED: Left Column Container (Title, Info, Selector, Toggle) *** */
    #globalControlColumn { /* Renamed from globalRightColumn */
        /* flex: 0 0 145px; */
        flex: 0 0 180px; /* Increased width for control column */
        display: flex;
        flex-direction: column;
        align-items: flex-start; /* Left-align items within column */
        padding-top: 10px; /* Add some top padding */
    }

    /* Canvas Container (Now on the right) */
    #globalDoughnutDiv {
       /* flex: 1 1 640px; */
       flex: 1 1 calc(1040px - 180px - 15px); /* wrapper_width - control_col_width - gap = 845px */
       /* max-width: 640px; */
       max-width: calc(1040px - 180px - 15px); /* Ensure it doesn't exceed calculated space */
    }
    #globalDoughnutCanvas {
        display: block; /* Prevent extra space below canvas */
        width: 100%; /* Make canvas responsive within its div */
        height: auto;
    }

    /* Title above Info Box */
    #globalPlotTitle {
        /* font-family, font-weight, font-size, line-height, color defined in common header style */
        margin-bottom: 15px; /* Consistent spacing */
        /* color: #333; */ /* Overridden */
        width: 100%; /* Ensure title takes width for alignment */
        text-align: left; /* Left align title */
    }

    /* Info Box Styling */
    #globalInfoBox {
        width: 100%; /* Take full width of the column */
        padding: 10px;
        border: 1px solid #eee;
        border-radius: 8px;
        background-color: #fdfdfd;
        font-size: 0.9em; /* Approx 17px from 19px base */
        margin-bottom: 15px; /* Consistent spacing */
        text-align: left; /* Left align text */
    }
     #globalInfoBox p { margin: 0.5em 0; }
     #globalInfoBox strong { font-weight: bold; }

    /* Selector Styling */
    #globalSelectorBox {
        width: 100%; /* Take full width of the column */
        margin-bottom: 15px; /* Consistent spacing */
        text-align: left; /* Left align label/select */
    }
     /* Styles for the new global plot selector */
    #globalSelectorBox label { /* Label for the search input */
        display: block;
        margin-bottom: 8px; /* Increased space */
        font-weight: bold; /* Will inherit Nunito Sans */
    }
    #globalPlotSearchInput {
        width: 100%;
        padding: 8px;
        margin-bottom: 8px; /* Increased space */
        border: 1px solid #ccc;
        border-radius: 4px;
        font-family: 'Nunito Sans', sans-serif; /* Ensure consistent font */
    }
    #globalPlotListContainer {
        max-height: 150px; /* Increased height */
        overflow-y: auto;
        border: 1px solid #eee;
        border-radius: 4px;
    }

    /* Canvas Gridline Toggle Styling */
    #canvasGridlineToggleBox {
        width: 100%; /* Take full width */
        /* margin-top: 40px; Removed, will rely on margin-bottom of element above */
        text-align: left; /* Align checkbox/label left */
    }
     #canvasGridlineToggleBox label { font-weight: normal; cursor: pointer; margin-left: 5px; }
     #canvasGridlineToggleBox input { vertical-align: middle; cursor: pointer; }


    /* Controls and SVG Area */
    #controlsBox,
    #plotDisplayArea {
        /* max-width: 800px; */
        max-width: 1040px; /* Adjusted for 1080px site width */
        margin: 15px auto;
    }

    /* *** UPDATED: Data Table Container Styling *** */
    #dataTableContainer {
        /* max-width: 800px; */
        max-width: 1040px; /* Explicitly set max-width for desktop */
        margin: 20px auto 15px auto; /* Add margin top/bottom */
        padding: 10px;
        border-top: 1px solid #ccc;
    }

    /* --- Data Table Styling (Keep existing rules) --- */
    #dataTableContainer table {
        /* width: 90%; */ /* Changed to 100% to fill its container */
        width: 100%;
        table-layout: fixed; /* Force table to obey width */
        margin-top: 10px;
        margin-bottom: 20px;
        border-collapse: collapse; /* Approx 17px from 19px base */
        font-size: 0.9em;
    }
    #dataTableContainer th,
    #dataTableContainer td {
        word-break: break-word; /* Wrap long text in cells */
        overflow-wrap: break-word; /* Ensure wrapping */
        border: 1px solid #ddd;
        padding: 6px;
        text-align: left;
    }
    #dataTableContainer th {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    #dataTableContainer h4 { /* Style for plot name headings */
        /* font-family, font-weight, font-size, line-height, color defined in common header style */
        margin-top: 15px;
        margin-bottom: 5px;
        /* font-size: 1.1em; */ /* Overridden */
    }


    #controlsBox {
        padding: 15px 0px;
    }
    #controlsBox > label { /* Style for "Search & Select..." and "Currently Displaying..." */
        /* font-family, font-weight, font-size, line-height, color defined in common header style */
        display: block; /* Make them block to take full width and allow margin */
        margin-bottom: 8px; /* Add some space below */
    }

    #plotDisplayArea {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start;
        padding: 0;
    }


    /* --- Controls Styling --- */
    #searchListWrapper {
        border: 1px solid #ccc;
        border-radius: 4px;
        margin-bottom: 10px;
        overflow: hidden;
        background-color: #fff;
    }

    #plotSearchInput {
        width: 100%;
        padding: 10px;
        padding: 8px; /* Standardized padding */
        border: none;
        border-bottom: 1px solid #ddd; /* Slightly darker for better definition */
        border-radius: 0;
        outline: none;
    }
    #plotSearchInput::placeholder { color: #aaa; }

    #plotListContainer {
        max-height: 150px;
        overflow-y: auto;
        border: none;
        padding: 5px;
    }

    .plot-list-item { display: block; margin-bottom: 4px; padding: 3px 8px; border-radius: 3px; cursor: pointer; transition: background-color 0.2s; }
    .plot-list-item:hover { background-color: #f0f0f0; }
    .plot-list-item.pinned { font-weight: bold; background-color: #e8f0fe; border-bottom: 1px solid #ccc; margin-bottom: 6px; }
    .plot-list-item.pinned:hover { background-color: #dbe7fd; }
    .plot-list-item label { margin-left: 5px; cursor: pointer; font-weight: normal; } /* Will inherit Nunito Sans */
    .plot-list-item input[type="checkbox"] { cursor: pointer; vertical-align: middle; }

    /* Styling for items in the new global plot list */
    .global-plot-list-item {
        display: block; padding: 6px 10px; cursor: pointer;
        border-bottom: 1px solid #f0f0f0; font-size: 0.9em; /* Approx 17px */
    }
    .global-plot-list-item:last-child { border-bottom: none; }
    .global-plot-list-item:hover, .global-plot-list-item.selected { background-color: #e8f0fe; }
    #listActions { margin-bottom: 10px; text-align: right; }
    
    .plot-list-item, #listActions button, .selected-plot-tag {
        font-size: 0.85em; /* approx 16px from 19px base, for better fit */
    }
    #listActions button {
        padding: 4px 10px; margin-left: 5px; font-size: 0.9em; cursor: pointer;
        background-color: #fff;
        border: 1px solid rgb(34, 35, 34);
        color: rgb(34, 35, 34);
        border-radius: 4px;
        transition: background-color 0.2s, color 0.2s;
    }
    #listActions button:hover { background-color: rgb(34, 35, 34); color: #fff; }


    #selectedPlotsDisplayBox { margin-top: 10px; padding: 8px 0px; min-height: 30px; }
    .selected-plot-tag { display: inline-block; background-color: #e0e0e0; color: #333; padding: 3px 8px; margin: 3px; border-radius: 12px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s; }
    .selected-plot-tag:hover { background-color: #f47a7a; color: white; }
    .selected-plot-tag::after { content: ' \00d7'; font-weight: bold; margin-left: 4px; }

    /* SVG Label Toggle */
    #svgLabelToggleBox {
        margin-bottom: 10px;
        text-align: right;
    }
     #svgLabelToggleBox label {
        font-weight: normal; /* Make toggle label normal weight */
        margin-left: 5px;
        cursor: pointer;
     }
     #svgLabelToggleBox input[type="checkbox"] {
        vertical-align: middle;
        cursor: pointer;
     }


    /* --- Plot Display Styling (SVG Section) --- */
    .plot-container {
        flex: 1 1 25%;
        min-width: 250px;
        max-width: 100%;
        margin: 0;
        text-align: center;
        padding: 5px;
        overflow: hidden;
    }

    #plotDisplayArea.multi-row .plot-container {
        flex-grow: 0;
        flex-shrink: 0;
        flex-basis: 25%;
        max-width: 25%;
        min-width: 0;
    }

    /* SVG Scaling */
    .plot-container svg {
        display: block;
        width: 100%;
        height: auto;
        max-width: 100%;
    }

    .plot-title {
        font-size: 1.05em;
        font-weight: bold; /* Will use Nunito Sans bold, approx 20px */
        margin-bottom: 4px;
        color: #333;
        padding-bottom: 0;
    }
    /* label { margin-right: 5px; font-weight: bold; } */ /* General label - mostly overridden or handled by specific selectors */

    /* --- Data Table Styling --- */
    #dataTableContainer table {
        width: 100%; /* Fill its container */
        table-layout: fixed; /* Force table to obey width */
        margin-top: 10px;
        margin-bottom: 20px;
        border-collapse: collapse; /* Approx 17px from 19px base */
        font-size: 0.9em;
    }
    #dataTableContainer th,
    #dataTableContainer td {
        word-break: break-word; /* Wrap long text in cells */
        overflow-wrap: break-word; /* Ensure wrapping */
        border: 1px solid #ddd;
        padding: 6px;
        text-align: left;
    }
    #dataTableContainer th {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    /* #dataTableContainer h4 styling moved to common header style section */
    /* #dataTableContainer h4 { 
        margin-top: 15px;
        margin-bottom: 5px;
        font-size: 1.1em;
    } */

    /* --- Mobile Responsiveness --- */
    @media (max-width: 768px) { /* Tablet and smaller */
        body {
            font-size: 17px; /* Slightly smaller base font */
        }

        #globalPlotTitle,
        #controlsBox > label,
        #dataTableContainer h4 {
            font-size: 24px; /* Slightly smaller headers */
        }

        #globalDisplayWrapper {
            flex-direction: column; /* Stack canvas and controls */
            max-width: 95%; /* Allow a bit more width on tablets */
        }

        #globalControlColumn,
        #globalDoughnutDiv {
            flex-basis: auto; /* Allow natural sizing in column */
            width: 100%;      /* Take full width */
            max-width: 100%;
        }
        #globalControlColumn {
            flex: 0 0 auto; /* Don't grow/shrink, auto basis */
        }

        #controlsBox,
        #plotDisplayArea,
        #dataTableContainer {
            max-width: 95%;
        }

        #plotDisplayArea.multi-row .plot-container {
            flex-basis: 50%; /* 2 plots per row */
            max-width: 50%;
        }

        .plot-list-item, #listActions button, .selected-plot-tag {
            font-size: 0.9em; /* Adjust for smaller base font */
        }
    }

    @media (max-width: 480px) { /* Mobile phones */
        body {
            font-size: 16px; /* Even smaller base font */
        }
        #plotDisplayArea.multi-row .plot-container {
            flex-basis: 100%; /* 1 plot per row */
            max-width: 100%;
        }
    }
</style>

<body>

    <!-- 1. Permanent Global Plot Area (Canvas + Controls) -->
    <div id="globalDisplayWrapper">
        <!-- *** MOVED: Left Column for Title, Info, Selector, Toggle *** -->
        <div id="globalControlColumn"> <!-- Renamed from globalRightColumn -->
            <h4 id="globalPlotTitle">Global</h4>
            <div id="globalSelectorBox">
                <!-- New Global Plot Selector UI -->
                <label for="globalPlotSearchInput">Select plot:</label>
                <input type="text" id="globalPlotSearchInput" oninput="filterGlobalPlotList()" placeholder="Search plot...">
                <div id="globalPlotListContainer">
                    <p style="padding: 5px; color: #888;">Loading plots...</p>
                </div>
            </div>
            <div id="globalInfoBox">
                <p><strong>Hover:</strong> <span id="globalHoverInfo">None</span></p>
                <p><strong>Selected:</strong> <span id="globalSelectedInfo">None</span></p>
            </div>
            <div id="canvasGridlineToggleBox"> <!-- Moved Gridline Toggle after InfoBox -->
                <input type="checkbox" id="canvasGridlineToggle" onchange="toggleCanvasGridlines()">
                <label for="canvasGridlineToggle" style="font-weight: normal; cursor: pointer;">Show Gridlines</label>
            </div>
        </div>
        <!-- *** END MOVED Left Column *** -->

        <!-- Canvas Container (Now on the right) -->
        <div id="globalDoughnutDiv">
             <canvas id="globalDoughnutCanvas">Your browser does not support the HTML5 canvas tag.</canvas>
        </div>
    </div> <!-- End #globalDisplayWrapper -->


    <!-- *** MOVED: Area for the SINGLE Data Table (Linked to Canvas) *** -->
    <div id="dataTableContainer" style="margin-top: 20px; padding: 10px; border-top: 1px solid #ccc;">
        <!-- Single data table will be inserted here by JavaScript -->
    </div>
    <!-- *** END MOVED Data Table Container *** -->


    <!-- 2. Controls for SVG Plots -->
    <div id="controlsBox">
        <!-- ... existing SVG controls remain here ... -->
        <label for="plotSearchInput">Search & Select Plot(s) for Below:</label>
        <div id="searchListWrapper">
            <input type="text" id="plotSearchInput" oninput="filterPlotList()" placeholder="Start typing to filter plots...">
            <div id="plotListContainer">
                <p>Loading plots...</p>
            </div>
        </div>
        <div id="listActions">
            <button onclick="selectAllPlots()">Select All Visible</button>
            <button onclick="deselectAllPlots()">Deselect All</button>
        </div>
        <div id="svgLabelToggleBox">
            <input type="checkbox" id="svgLabelToggle" onchange="toggleSvgLabels()">
            <label for="svgLabelToggle">Show Labels</label>
        </div>
        <div id="gridlineToggleBox" style="margin-bottom: 10px; text-align: right;">
            <input type="checkbox" id="gridlineToggle" onchange="toggleSvgGridlines()">
            <label for="gridlineToggle">Show SVG Gridlines</label>
        </div>
        <label>Currently displaying:</label>
        <div id="selectedPlotsDisplayBox">
             <span style="color: #888; font-style: italic;">None</span>
        </div>
    </div> <!-- End #controlsBox -->


    <!-- 3. Area where selectable SVG plots will be displayed -->
    <div id="plotDisplayArea">
        <!-- Selectable SVGs will be injected here -->
    </div>


    <!-- Hidden elements needed for SVG initialization -->
    <canvas id="doughnutCanvas" style="display: none;"></canvas>
    <div id="doughnutDiv" style="display: none;"></div>

    <!-- Debug area (optional) -->
    <p id="debug" style="display: none;"></p>


    <!-- Load JS libraries -->
    <script src="doughnut.js?v=2.4"></script> <!-- Use correct cache-busting version -->
    <script src="doughnut_svg.js?v=2.4"></script> <!-- Use correct cache-busting version -->
    <script src="canvas2svg.js"></script>

    <script>
        // --- Constants ---
        const globalPlotName = "Global";
        const plotSize = 640;
        const plotScale = 1.0;
        const plotTextSize = 14;
        const maxPlotsFirstRow = 4;
        const defaultSelectedPlots = ["Afghanistan", "Honduras", "United States"];

        // --- Global variables ---
        let allPlotData = null; // Will store { plotName: [ { dimensionType, dimensionName, value, levelLabel }, ... ], ... }
        let plotDimensionDataCache = {};
        let globalDonutInstance = null; // Instance for the top Canvas plot
        let isSvgLabelsVisible = false; // State for SVG label visibility
        let isSvgGridlinesVisible = false; // State for SVG gridlines (controlled by #gridlineToggle)
        let isCanvasGridlinesVisible = false; // State for Canvas gridlines (controlled by #canvasGridlineToggle)
        let sortedPlotNames = []; // Keep sorted list globally

        // --- Robust CSV Line Parser ---
        function parseCsvLine(line) {
            const values = [];
            // Regex to match quoted or unquoted fields, handling commas correctly
            const regex = /(?:"([^"]*(?:""[^"]*)*)"|([^,]*))(?:,|$)/g; // Handles escaped quotes ""
            let match;
            regex.lastIndex = 0; // Reset index for global regex

            while ((match = regex.exec(line)) !== null) {
                let value = '';
                if (match[1] !== undefined) {
                    // Quoted field: replace escaped double quotes "" with single "
                    value = match[1].replace(/""/g, '"');
                } else if (match[2] !== undefined) {
                    // Unquoted field
                    value = match[2];
                }
                values.push(value.trim()); // Add the extracted value, trimmed

                // Stop if the regex match didn't end with a comma (i.e., end of line)
                if (match[0].slice(-1) !== ',') break;
            }
            // Handle cases where the line might end with a comma (empty last field)
            if (line.slice(-1) === ',' && values.length > 0) {
                 values.push('');
            }
            return values;
        }

        // --- Modified CSV Parsing Function (Stores Objects) ---
        function parsePlotDataCSV(csvString) {
            const lines = csvString.trim().split('\n');
            const plots = {}; // Object to hold plot data
            if (lines.length <= 1) return plots; // Handle empty or header-only CSV

            // Skip header row (i=0)
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue; // Skip empty lines

                const values = parseCsvLine(line); // Use robust parser

                // Expecting: PlotName, Type, Name, Value, Label
                if (values.length >= 5) { // Check if we got at least 5 values
                    const plotName = values[0]; // Correctly parsed name
                    const dimensionType = values[1] || '';
                    const dimensionName = values[2] || '';
                    const value = values[3] || '';
                    const levelLabel = values[4] || '';

                    if (!plots[plotName]) {
                        plots[plotName] = []; // Initialize array for this plot if new
                    }
                    // Store structured data object
                    plots[plotName].push({ dimensionType, dimensionName, value, levelLabel });

                } else {
                     console.warn(`Skipping invalid CSV line after parsing: ${line} -> Parsed:`, values);
                }
            }
            return plots; // Return the object containing arrays of data objects
         }

        // --- Function to Create a Checkbox Item ---
        function createCheckboxItem(name, isPinned = false) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'plot-list-item';
            if (isPinned) itemDiv.classList.add('pinned');

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            // Sanitize name for ID - replace non-alphanumeric with hyphen
            const safeId = `plot-checkbox-${name.replace(/[^a-zA-Z0-9]/g, '-')}`;
            checkbox.id = safeId;
            checkbox.value = name;
            checkbox.onchange = handlePlotSelectionChange;

            // Check if this plot should be initially selected
            if (defaultSelectedPlots.includes(name)) {
                checkbox.checked = true;
            }

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = name; // Display original name

            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            return itemDiv;
        }

        // --- Function to Populate Checkbox List and Global Selector ---
        function populatePlotList(plotNames) { // Accepts sorted plot names
            const listContainer = document.getElementById('plotListContainer');
            const globalPlotListDiv = document.getElementById('globalPlotListContainer'); // New global list

            listContainer.innerHTML = '';
            globalPlotListDiv.innerHTML = ''; // Clear new global list

            if (!plotNames || plotNames.length === 0) {
                listContainer.innerHTML = '<p>No plots found</p>';
                globalPlotListDiv.innerHTML = '<p style="padding: 5px; color: #888;">No plots found</p>';
                return;
            }

            let globalExists = plotNames.includes(globalPlotName);
            let firstPlotSelected = false;

            // Populate SVG Checkbox List
            // Pin Global plot if it exists
            if (globalExists) {
                listContainer.appendChild(createCheckboxItem(globalPlotName, true));
            }
            // Add other plots, already sorted
            plotNames.filter(name => name !== globalPlotName).forEach(name => {
                listContainer.appendChild(createCheckboxItem(name, false));
            });

            // Populate New Global Canvas Selector List
            plotNames.forEach(name => {
                const item = document.createElement('div');
                item.className = 'global-plot-list-item';
                item.textContent = name;
                item.dataset.plotname = name;
                item.onclick = function() { selectGlobalPlotFromList(name, this); };
                globalPlotListDiv.appendChild(item);

                if (name === globalPlotName && !firstPlotSelected) {
                    item.classList.add('selected'); // Highlight "Global" by default
                    firstPlotSelected = true;
                }
            });

            // If "Global" wasn't found but list isn't empty, select the first actual plot
            if (!firstPlotSelected && globalPlotListDiv.firstChild && globalPlotListDiv.firstChild.classList) {
                globalPlotListDiv.firstChild.classList.add('selected');
                // Optionally, call changeGlobalPlot here if the first item should load immediately
            }
         }
        // --- Function to Filter Checkbox List ---
        function filterPlotList() {
            const searchTerm = document.getElementById('plotSearchInput').value.toLowerCase();
            const items = document.querySelectorAll('#plotListContainer .plot-list-item');
            items.forEach(item => {
                const label = item.querySelector('label');
                const plotName = label.textContent.toLowerCase(); // Use original name for searching
                // Show pinned items OR items matching the search term
                item.style.display = (item.classList.contains('pinned') || plotName.includes(searchTerm)) ? 'block' : 'none';
            });
         }

        // --- New Function to Filter Global Plot List ---
        function filterGlobalPlotList() {
            const searchTerm = document.getElementById('globalPlotSearchInput').value.toLowerCase();
            const items = document.querySelectorAll('#globalPlotListContainer .global-plot-list-item');
            items.forEach(item => {
                const plotName = item.textContent.toLowerCase();
                // Show item if it matches the search term
                item.style.display = plotName.includes(searchTerm) ? 'block' : 'none';
            });
        }


        // --- Select/Deselect All Functions ---
        function selectAllPlots() {
            const checkboxes = document.querySelectorAll('#plotListContainer input[type="checkbox"]');
            checkboxes.forEach(cb => {
                // Only check if the item is currently visible (respects filter)
                if (cb.closest('.plot-list-item').style.display !== 'none') {
                    cb.checked = true;
                }
            });
            handlePlotSelectionChange(); // Update display
        }

        function deselectAllPlots() {
            const checkboxes = document.querySelectorAll('#plotListContainer input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            handlePlotSelectionChange(); // Update display
        }

        // --- Function to Load Data into a Doughnut Instance ---
        function loadSpecificPlotData(plotName, targetInstance) {
             if (!targetInstance || !allPlotData || !allPlotData[plotName]) return false;
             const plotDataRows = allPlotData[plotName]; // Get the array of data objects

             if (plotDataRows.length > 0) {
                plotDataRows.forEach(row => {
                    // Use the properties from the stored object
                    targetInstance.addDimension(row.dimensionType, row.dimensionName, row.value, row.levelLabel);
                });
                return true;
             }
             return false;
        }

        // --- Function to Import Data and Cache (Only for SVG generation) ---
        function importAndCacheDataForSVG(plotName, targetInstance) {
             if (!targetInstance || !allPlotData || !allPlotData[plotName]) return null;

             // Check cache first
             if (plotDimensionDataCache[plotName]) {
                 const cachedData = plotDimensionDataCache[plotName];
                 // Load from cache directly into the instance
                 cachedData.inner.forEach(dim => dim.levels.forEach(lvl => targetInstance.addDimension('inner', dim.name, lvl.value, lvl.label)));
                 cachedData.outer.forEach(dim => dim.levels.forEach(lvl => targetInstance.addDimension('outer', dim.name, lvl.value, lvl.label)));
                 return cachedData; // Return cached structured data
             }

             // Not cached: Load data into the instance
             loadSpecificPlotData(plotName, targetInstance);

             // Cache the structured data from the instance *after* loading
             // Use JSON stringify/parse for a deep copy to avoid mutation issues
             const structuredData = {
                 inner: JSON.parse(JSON.stringify(targetInstance._innerDims.dimensions)),
                 outer: JSON.parse(JSON.stringify(targetInstance._outerDims.dimensions))
             };
             plotDimensionDataCache[plotName] = structuredData;

             return structuredData; // Return the newly created structured data
        }


        // --- Function to Generate SVG (Simplified) ---
        function generateAndProcessSVG(plotName, instance) {
            const svgString = instance.exportSVG();
            let finalSvgElement = null;
            try {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
                const svgRoot = svgDoc.documentElement;

                if (svgRoot && svgRoot.tagName.toLowerCase() === 'svg') {
                    // Make SVG responsive
                    svgRoot.setAttribute('viewBox', `0 0 ${plotSize} ${plotSize}`);
                    svgRoot.removeAttribute('width');
                    svgRoot.removeAttribute('height');
                    svgRoot.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    finalSvgElement = svgRoot;
                } else { console.warn(`Could not parse SVG for plot: ${plotName}`); }
            } catch (e) { console.error(`Error processing SVG for plot ${plotName}:`, e); }
            return finalSvgElement;
        }

        // --- Function to Update Canvas Info Box Text ---
        // Modified to accept selectedText as well
        function updateGlobalInfoText(hoverText, selectedText) {
             const hoverSpan = document.getElementById('globalHoverInfo');
             if (hoverSpan) hoverSpan.textContent = hoverText || "None";
             const selectedSpan = document.getElementById('globalSelectedInfo');
             if (selectedSpan) selectedSpan.textContent = selectedText || "None";
        }



        // --- Function to Sanitize String for Use as ID ---
        function sanitizeId(str) {
            // Replace non-alphanumeric characters with hyphens
            return str.replace(/[^a-zA-Z0-9]/g, '-');
        }

        // --- Function to Update the Displayed SVG Plots ---
        // REPLACE the existing updateDisplayedPlots function in embed.html

        function updateDisplayedPlots(selectedPlotNames) {
        const plotDisplayArea = document.getElementById('plotDisplayArea');
        if (!plotDisplayArea) return;

        plotDisplayArea.innerHTML = ''; // Clear previous plots
        plotDisplayArea.classList.toggle('multi-row', selectedPlotNames.length >= maxPlotsFirstRow);

        if (selectedPlotNames.length === 0) {
             plotDisplayArea.innerHTML = '<p style="text-align: center; width: 100%; color: #555;">Select plots from the list above.</p>';
             // *** REMOVED call to updateDataTable([]) ***
             return;
        }

        selectedPlotNames.forEach(plotName => {
            if (allPlotData[plotName]) {
                const plotContainer = document.createElement('div');
                plotContainer.id = `plot-${sanitizeId(plotName)}`;
                plotContainer.className = 'plot-container';

                const plotTitle = document.createElement('p');
                plotTitle.className = 'plot-title';
                plotTitle.textContent = plotName;
                plotContainer.appendChild(plotTitle);

                const tempDonutSVG = new Doughnut_SVG(plotSize, plotScale, plotTextSize,
                    "doughnutCanvas", "doughnutDiv", null, null, null, null);

                importAndCacheDataForSVG(plotName, tempDonutSVG);

                tempDonutSVG.setLabelsVisible(isSvgLabelsVisible);
                tempDonutSVG.setGridlinesVisible(isSvgGridlinesVisible);

                const finalSvgElement = generateAndProcessSVG(plotName, tempDonutSVG);

                if (finalSvgElement) {
                    plotContainer.appendChild(finalSvgElement);
                } else {
                    plotContainer.innerHTML += '<p style="color:red;">Error generating plot</p>';
                }
                plotDisplayArea.appendChild(plotContainer);
            } else {
                console.warn(`Data not found for selected plot: ${plotName}`);
            }
        });

        // *** REMOVED call to updateDataTable(selectedPlotNames) ***
    }


        // --- Function to handle checkbox changes and update display ---
        function handlePlotSelectionChange() {
        const selectedPlotsBox = document.getElementById('selectedPlotsDisplayBox');
        const checkboxes = document.querySelectorAll('#plotListContainer input[type="checkbox"]');
        const selectedPlotNames = [];

        checkboxes.forEach(cb => { if (cb.checked) selectedPlotNames.push(cb.value); });

        // Update the tags display
        if (selectedPlotsBox) selectedPlotsBox.innerHTML = ''; // Clear previous tags
        if (selectedPlotNames.length > 0) {
            selectedPlotNames.sort((a, b) => {
                if (a === globalPlotName) return -1;
                if (b === globalPlotName) return 1;
                return a.localeCompare(b);
            });

            selectedPlotNames.forEach(name => {
                const tag = document.createElement('span');
                tag.className = 'selected-plot-tag';
                tag.textContent = name;
                tag.dataset.plotName = name;
                tag.onclick = handleTagClick;
                selectedPlotsBox.appendChild(tag);
            });
        } else {
            if (selectedPlotsBox) selectedPlotsBox.innerHTML = '<span style="color: #888; font-style: italic;">None</span>';
        }

        // Update ONLY the SVG plots display area
        updateDisplayedPlots(selectedPlotNames); // Pass the selected names for SVGs

        // *** REMOVED call to updateDataTable(selectedPlotNames) ***
     }

        // --- Function to handle clicking on a selected plot tag ---
        function handleTagClick(event) {
             const plotNameToRemove = event.target.dataset.plotName;
            if (!plotNameToRemove) return;
            // Sanitize name to find the correct checkbox ID
            const safeId = `plot-checkbox-${plotNameToRemove.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const checkbox = document.getElementById(safeId);
            if (checkbox) {
                checkbox.checked = false; // Uncheck the box
                handlePlotSelectionChange(); // Trigger update
            } else { console.warn(`Could not find checkbox for tag: ${plotNameToRemove}`); }
         }

        // --- New Function to Select a Plot from the Global List ---
        function selectGlobalPlotFromList(plotName, clickedElement) {
            // Remove 'selected' class from all other items in this list
            const allGlobalItems = document.querySelectorAll('#globalPlotListContainer .global-plot-list-item');
            allGlobalItems.forEach(item => item.classList.remove('selected'));

            // Add 'selected' class to the clicked item
            if (clickedElement) {
                clickedElement.classList.add('selected');
            }

            // Call the function to change the plot
            changeGlobalPlot(plotName);
        }


         // --- Modified Function to Change the Global Canvas Plot ---
         function changeGlobalPlot(plotNameToLoad) { // Now accepts plotName as argument
            const titleElement = document.getElementById('globalPlotTitle');

            if (globalDonutInstance && plotNameToLoad && allPlotData[plotNameToLoad]) {
                console.log(`Changing global canvas plot to: ${plotNameToLoad}`);
                globalDonutInstance.clearDoughnut();
                loadSpecificPlotData(plotNameToLoad, globalDonutInstance);
                globalDonutInstance.setLabelsVisible(true); // Keep labels on for canvas
                globalDonutInstance.setGridlinesVisible(isCanvasGridlinesVisible); // Reflect current toggle state

                if (titleElement) titleElement.textContent = plotNameToLoad;
                updateGlobalInfoText("None", "None"); // Clear hover and selected info

                updateDataTable(plotNameToLoad); // Update data table for the new plot
            } else {
                console.warn(`Could not change global plot to: ${plotNameToLoad}. Data or instance missing.`);
            }
     }

         // --- Function to Toggle SVG Labels ---
         function toggleSvgLabels() {
            const checkbox = document.getElementById('svgLabelToggle');
            isSvgLabelsVisible = checkbox.checked; // Update global state

            // Find all SVG plots currently displayed
            const plotContainers = document.querySelectorAll('#plotDisplayArea .plot-container');
            plotContainers.forEach(container => {
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    // Find all text elements within this SVG
                    const textElements = svgElement.querySelectorAll('text');
                    // Toggle visibility based on the global state
                    textElements.forEach(textEl => {
                        textEl.style.visibility = isSvgLabelsVisible ? 'visible' : 'hidden';
                    });
                }
            });
         }

         function toggleSvgGridlines() {
            const checkbox = document.getElementById('gridlineToggle');
            isSvgGridlinesVisible = checkbox.checked; // Update state

            // 1. Update the main canvas instance immediately
            if (globalDonutInstance) {
                globalDonutInstance.setGridlinesVisible(isGridlinesVisible);
            }

            // 2. Trigger regeneration of displayed SVG plots
            //    (Calling handlePlotSelectionChange reads current selections and updates SVGs)
            handlePlotSelectionChange();
        }

        function toggleCanvasGridlines() {
        const checkbox = document.getElementById('canvasGridlineToggle');
        isCanvasGridlinesVisible = checkbox.checked; // Update Canvas state variable

        // Update the main canvas instance immediately
        if (globalDonutInstance) {
            globalDonutInstance.setGridlinesVisible(isCanvasGridlinesVisible);
        }
    }


        // --- Function to Update the Data Table ---
        function updateDataTable(plotName) { // Changed parameter to single plotName
        const container = document.getElementById('dataTableContainer');
        if (!container) return; // Exit if container not found

        container.innerHTML = ''; // Clear previous table

        // Check if a valid plotName is provided
        if (!plotName || !allPlotData || !allPlotData[plotName]) {
            container.innerHTML = '<p>Select a plot in the main canvas area to view its data.</p>';
            return;
        }

        // Get data for the single selected plot
        const plotSpecificData = allPlotData[plotName];
        let tableHtml = '';

        if (plotSpecificData && plotSpecificData.length > 0) {
            // Add a heading for the plot's table
            tableHtml += `<h4>${plotName.replace(/^"|"$/g, '')} data</h4>`; // Remove quotes for display

            tableHtml += `
                <table>
                    <thead>
                        <tr>
                            <th>Dimension Name</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Sort data alphabetically by DimensionName for consistency
            // const sortedData = plotSpecificData.slice().sort((a, b) => a.dimensionName.localeCompare(b.dimensionName)); // Removed sorting

            plotSpecificData.forEach(dataRow => { // Iterate over original order
                tableHtml += `
                    <tr>
                        <td>${dataRow.dimensionName}</td>
                        <td>${dataRow.value}</td>
                    </tr>
                `;
            });

            tableHtml += `
                    </tbody>
                </table>
            `;
        } else {
             tableHtml += `<h4>No data found for: ${plotName.replace(/^"|"$/g, '')}</h4>`;
        }

        container.innerHTML = tableHtml;
    }


        // --- Fetch and Process CSV on Page Load ---
        async function initializePlots() {
        try {
            const response = await fetch('doughnut_CSV.csv');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const csvString = await response.text();
            allPlotData = parsePlotDataCSV(csvString);

            await document.fonts.ready;
            console.log("Fonts loaded, proceeding with Doughnut initialization.");

            const globalInfoBox = document.getElementById('globalInfoBox');
            const globalPlotTitleEl = document.getElementById('globalPlotTitle');

            if (allPlotData[globalPlotName] && globalInfoBox) {
                globalDonutInstance = new Doughnut(
                    plotSize, plotScale, plotTextSize,
                    "globalDoughnutCanvas", "globalDoughnutDiv", null, null, null, null
                );
                // Override _updateInfo to use the new structure
                globalDonutInstance._updateInfo = function(currentHoverText, currentSelectedText) {
                    updateGlobalInfoText(currentHoverText, currentSelectedText);
                };

                loadSpecificPlotData(globalPlotName, globalDonutInstance);
                globalDonutInstance.setLabelsVisible(true);
                globalDonutInstance.setGridlinesVisible(isCanvasGridlinesVisible);

                globalDonutInstance._canvas.addEventListener("mousemove", (e) => { globalDonutInstance._checkMouse(e); });
                globalDonutInstance._canvas.addEventListener("mouseleave", (e) => {
                    updateGlobalInfoText("None");
                    // Selected info remains
                    if (globalDonutInstance && globalDonutInstance._canvas) globalDonutInstance._canvas.style.cursor = "default";
                });

                if(globalPlotTitleEl) globalPlotTitleEl.textContent = globalPlotName;
                updateGlobalInfoText("None");

                // *** ADD initial call to update data table for canvas plot ***
                updateDataTable(globalPlotName);
                // *** END ADD call ***

            } else { /* ... error handling ... */ }

            let plotNames = Object.keys(allPlotData);
            sortedPlotNames = plotNames.sort((a, b) => { /* ... sorting ... */ });

            populatePlotList(sortedPlotNames);
            // Initial call to changeGlobalPlot if "Global" is the default and should load its data table
            if (sortedPlotNames.includes(globalPlotName)) {
                 changeGlobalPlot(globalPlotName); // This will also call updateDataTable
            }
            handlePlotSelectionChange(); // Renders initial SVGs

            // Set initial state of toggle checkboxes
            const svgLabelCheckbox = document.getElementById('svgLabelToggle');
            if (svgLabelCheckbox) svgLabelCheckbox.checked = isSvgLabelsVisible;
            const svgGridlineCheckbox = document.getElementById('gridlineToggle');
            if (svgGridlineCheckbox) svgGridlineCheckbox.checked = isSvgGridlinesVisible;
            const canvasGridlineCheckbox = document.getElementById('canvasGridlineToggle');
            if (canvasGridlineCheckbox) canvasGridlineCheckbox.checked = isCanvasGridlinesVisible;

        } catch (error) { /* ... error handling ... */ }
    }
    // *** END modified initializePlots ***

    // --- Initialize ---
    initializePlots();

    </script>

</body>
</html>
